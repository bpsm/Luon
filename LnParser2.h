#ifndef __LN_PARSER2__
#define __LN_PARSER2__

/*
** Copyright (C) 2024 Rochus Keller (me@rochus-keller.ch)
**
** This file is part of the Luon language project.
**
**
** GNU Lesser General Public License Usage
** This file may be used under the terms of the GNU Lesser
** General Public License version 2.1 or version 3 as published by the Free
** Software Foundation and appearing in the file LICENSE.LGPLv21 and
** LICENSE.LGPLv3 included in the packaging of this file. Please review the
** following information to ensure the GNU Lesser General Public License
** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
*/

// This file was originally automatically generated by EbnfStudio and then manually continued

#include <Luon/LnToken.h>
#include <Luon/LnAst.h>
#include <QList>

namespace Ln {

	class Scanner2 {
	public:
		virtual Token next() = 0;
		virtual Token peek(int offset) = 0;
        virtual QString source() const = 0;
        virtual QByteArrayList path() const { return QByteArrayList(); } // prefix without module name
    };

	class Parser2 {
	public:
        Parser2(AstModel* m, Scanner2* s):scanner(s),mdl(m),thisMod(0) {}
        ~Parser2();
        void RunParser();
        typedef QPair<Declaration*, QList<Type*> > Result; // module + list of temporary types
        Result takeResult(); // get module declaration and take ownership (otherwise deleted by parser)
        struct Error {
		    QString msg;
            RowCol pos;
		    QString path;
            Error( const QString& m, const RowCol& pos, const QString& p):msg(m),pos(pos),path(p){}
		};
		QList<Error> errors;
	protected:
		void Luon();
        Expression* number();
        Qualident qualident();
        struct IdentDef {
            Token name;
            enum Visi { Private, ReadOnly, Public } visi;
            bool isValid() const { return name.d_type == Tok_ident; }
        };
        IdentDef identdef();
		void ConstDeclaration();
        Expression* ConstExpression();
        void TypeDeclaration();
        Type* type(bool deanonymize = true);
        Type* NamedType();
        Type* ArrayType();
        Expression* length();
        Type* DictType();
        Type* RecordType();
        Type* BaseType();
		void FieldList();
        typedef QList<IdentDef> IdentDefList;
        IdentDefList IdentList();
        Type* enumeration();
        DeclList constEnum();
		void VariableDeclaration();
        Expression* designator(bool needsLvalue);
        Expression* expression(bool lvalue = false);
        quint8 relation();
        Expression* SimpleExpression(bool lvalue);
        quint8 AddOperator();
        Expression* term(bool lvalue);
        quint8 MulOperator();
        Expression* literal();
        Expression* constructor();
        enum { FirstComponent, Named, Anonymous };
        Expression* component();
        Expression* factor(bool lvalue = false);
        Expression* variableOrFunctionCall(bool lvalue);
        Statement* statement();
        Statement* assignmentOrProcedureCall();
        Statement* StatementSequence();
        Statement* IfStatement();
        Statement* ElsifStatement();
        Statement* ElseStatement();
        Statement* CaseStatement();
        Statement* Case();
        Expression* CaseLabelList();
        Expression* LabelRange();
        Expression* label();
        Statement* WhileStatement();
        Statement* RepeatStatement();
        Statement* ForStatement();
        Statement* LoopStatement();
        Statement* ExitStatement();
		void procedure();
        Type* ProcedureType();
		void ProcedureDeclaration();
        Qualident Receiver();
        Statement* block();
        void DeclarationSequence();
        Statement* ReturnStatement();
        Type* FormalParameters();
        Type* ReturnType();
		void FPSection();
        Type* FormalType();
		void module();
		void ImportList();
		void import();
        MetaParamList MetaParams();
        MetaParamList MetaSection(bool& isType);
    protected:
        Declaration* addDecl(const Token& id, quint8 visi, quint8 mode);
        Declaration* addDecl(const IdentDef& id, quint8 mode);
        void error( const Token&, const QString& msg);
        void error( const RowCol&, const QString& msg );
        Declaration* addHelper(Type* t);
        void clearTemps();

	protected:
        Declaration* thisMod;
        QList<Type*> componentTypeStack;
        QList<Type*> temporaries;
        AstModel* mdl;
        Token cur;
		Token la;
		Scanner2* scanner;
		void next();
		Token peek(int off);
		void invalid(const char* what);
		bool expect(int tt, bool pkw, const char* where);
	};
}
#endif // include
